//@version=5
indicator("Alice v1.4 - Nasdaq", overlay=true, max_boxes_count=500, max_labels_count=500, max_lines_count=500, dynamic_requests=true)

// ==========================================
// 1. AYARLAR (INPUTS)
// ==========================================
aliceGroup = "Alice Ayarlari"
macdSource = input.source(close, "MACD Kaynagi", group=aliceGroup)
macdFast = input.int(12, "Hizli EMA", group=aliceGroup)
macdSlow = input.int(26, "Yavas EMA", group=aliceGroup)
macdSignal = input.int(9, "Sinyal EMA", group=aliceGroup)

leftBars = input.int(2, "Fractal Left", group=aliceGroup)
rightBars = input.int(2, "Fractal Right", group=aliceGroup)
maxAgeBars = input.int(1500, "Max Age (bars)", group=aliceGroup)
minRR = input.float(0.1, "Minimum R:R Orani", group=aliceGroup, step=0.1) 
atrSLMultiplier = input.float(2.0, "ATR Stop Loss Multiplier", group=aliceGroup, step=0.1)

showEMA = input.bool(false, "EMAlari Goster", group=aliceGroup)
showSRBands = input.bool(true, "Destek/Direnc Goster", group=aliceGroup)
showBollinger = input.bool(false, "Bollinger Bantlarini Goster", group=aliceGroup)
showQQE = input.bool(false, "QQE Modu Goster", group=aliceGroup)
showZLT = input.bool(true, "Zero Lag Trendi Goster", group=aliceGroup)
showBreakLabels = input.bool(false, "Kirilim 'B' Etiketlerini Goster", group=aliceGroup)
showBuySignals = input.bool(true, title="Show Buy Signals")
showSellSignals = input.bool(true, title="Show Sell Signals")

// DASHBOARD VE FILTRE AYARLARI
dashGroup = "Dashboard & Filtreler"
showDashboard = input.bool(true, "Dashboardlari Goster", group=dashGroup) 
useSmartFilters = input.bool(true, "Akilli Filtreleri (Index/Stock) Aktif Et", group=dashGroup)
useZltTrendFilter = input.bool(true, "ZLT Trend Filtresi (Trend Tersi Islem Yok)", group=dashGroup)

// EXIT AYARLARI (YENI)
exitGroup = "Exit Stratejisi"
useTrailingPoints = input.bool(true, "Trailing Stop Puanlamasini Kullan (+20 Puan)", group=exitGroup)
atrTrailMult = input.float(2.5, "Trailing Stop ATR Çarpanı", group=exitGroup, step=0.1, tooltip="2.5 ideal dengedir. 2.0 çok sıkı, 3.0 çok gevşek takip eder.")

// QQE MOD AYARLARI
qqeGroup = "QQE Mod Settings"
qqeRsiLength = input.int(6, title="QQE RSI Length", group=qqeGroup)
qqeRsiSmoothing = input.int(5, title="QQE RSI Smoothing", group=qqeGroup)
qqeFactor = input.float(3.0, title="QQE Factor", group=qqeGroup)
qqeSource = input.source(close, title="QQE RSI Source", group=qqeGroup)

// ZERO LAG TREND AYARLARI
zltGroup = "Zero Lag Trend Settings"
zltLength = input.int(70, "ZLT Length", group = zltGroup)
zltMult = input.float(1.2, "ZLT Band Multiplier", group = zltGroup)

// VOLUMATIC VIDYA AYARLARI
vidyaGroup = "Volumatic VIDYA Settings"
showVolumaticVidya = input.bool(false, "Volumatic VIDYAYi Goster", group = vidyaGroup)
vidya_length = input.int(10, 'VIDYA Length', group = vidyaGroup)
vidya_momentum = input.int(20, 'VIDYA Momentum', group = vidyaGroup)
band_distance = input.float(2, 'Distance factor', step = 0.1, group = vidyaGroup)
vidya_up_trend_color = input.color(color.green, "VIDYA Up Color", group = vidyaGroup)
vidya_down_trend_color = input.color(color.red, "VIDYA Down Color", group = vidyaGroup)

// SMC AYARLARI
smcGroup = "SMC Ayarlari"
INTERNAL_GROUP = smcGroup + ' - Internal Structure'
SWING_GROUP = smcGroup + ' - Swing Structure'
BLOCKS_GROUP = smcGroup + ' - Order Blocks'
EQUAL_GROUP = smcGroup + ' - EQH/EQL'
GAPS_GROUP = smcGroup + ' - Fair Value Gaps'

// CONSTANTS
BULLISH_LEG = 1
BEARISH_LEG = 0
BULLISH = +1
BEARISH = -1
GREEN = #089981
RED = #F23645
ALL = 'All'
BOS = 'BOS'
CHOCH = 'CHoCH'
ATR = 'Atr'
RANGE = 'Cumulative Mean Range'
CLOSE = 'Close'
HIGHLOW = 'High/Low'
TINY = size.tiny
SMALL = size.small
SOLID = 'SOLID'
DASHED = 'DASHED'
DOTTED = 'DOTTED'

showInternalsInput = input(true, 'Show Internal Structure', group=INTERNAL_GROUP)
showInternalBullInput = input.string(ALL, 'Bullish Structure', group=INTERNAL_GROUP, inline='ibull', options=[ALL, BOS, CHOCH])
internalBullColorInput = input.color(GREEN, '', group=INTERNAL_GROUP, inline='ibull')
showInternalBearInput = input.string(ALL, 'Bearish Structure', group=INTERNAL_GROUP, inline='ibear', options=[ALL, BOS, CHOCH])
internalBearColorInput = input.color(RED, '', group=INTERNAL_GROUP, inline='ibear')
internalFilterConfluenceInput = input(false, 'Confluence Filter', group=INTERNAL_GROUP)

showStructureInput = input(true, 'Show Swing Structure', group=SWING_GROUP)
showSwingBullInput = input.string(ALL, 'Bullish Structure', group=SWING_GROUP, inline='bull', options=[ALL, BOS, CHOCH])
swingBullColorInput = input.color(GREEN, '', group=SWING_GROUP, inline='bull')
showSwingBearInput = input.string(ALL, 'Bearish Structure', group=SWING_GROUP, inline='bear', options=[ALL, BOS, CHOCH])
swingBearColorInput = input.color(RED, '', group=SWING_GROUP, inline='bear')
showSwingsInput = input(true, 'Show Swings Points', group=SWING_GROUP, inline='swings')
swingsLengthInput = input.int(50, '', group=SWING_GROUP, minval=10, inline='swings')
showHighLowSwingsInput = input(true, 'Show Strong/Weak High/Low', group=SWING_GROUP)

showInternalOrderBlocksInput = input(true, 'Internal Order Blocks', group=BLOCKS_GROUP, inline='iob')
internalOrderBlocksSizeInput = input.int(5, '', group=BLOCKS_GROUP, minval=1, maxval=20, inline='iob')
showSwingOrderBlocksInput = input(true, 'Swing Order Blocks', group=BLOCKS_GROUP, inline='ob')
swingOrderBlocksSizeInput = input.int(5, '', group=BLOCKS_GROUP, minval=1, maxval=20, inline='ob')
orderBlockFilterInput = input.string(ATR, 'Order Block Filter', group=BLOCKS_GROUP, options=[ATR, RANGE])
orderBlockMitigationInput = input.string(HIGHLOW, 'Order Block Mitigation', group=BLOCKS_GROUP, options=[CLOSE, HIGHLOW])

showEqualHighsLowsInput = input(true, 'Equal High/Low', group=EQUAL_GROUP)
equalHighsLowsLengthInput = input.int(3, 'Bars Confirmation', group=EQUAL_GROUP, minval=1)
equalHighsLowsThresholdInput = input.float(0.1, 'Threshold', group=EQUAL_GROUP, minval=0, maxval=0.5, step=0.1)

showFairValueGapsInput = input(true, 'Fair Value Gaps', group=GAPS_GROUP)
fairValueGapsThresholdInput = input.bool(true, 'Auto Threshold', group=GAPS_GROUP)
fairValueGapsTimeframeInput = input.timeframe('', 'Timeframe', group=GAPS_GROUP)
fairValueGapsExtendInput = input.int(1, 'Extend FVG', group=GAPS_GROUP, minval=0)

// 2. VERI YAPILARI
type alerts
    bool internalBullishBOS = false
    bool internalBearishBOS = false
    bool internalBullishCHoCH = false
    bool internalBearishCHoCH = false
    bool swingBullishBOS = false
    bool swingBearishBOS = false
    bool swingBullishCHoCH = false
    bool swingBearishCHoCH = false
    bool internalBullishOrderBlock = false
    bool internalBearishOrderBlock = false
    bool swingBullishOrderBlock = false
    bool swingBearishOrderBlock = false
    bool equalHighs = false
    bool equalLows = false
    bool bullishFairValueGap = false
    bool bearishFairValueGap = false

type trailingExtremes
    float top
    float bottom
    int barTime
    int barIndex
    int lastTopTime
    int lastBottomTime

type fairValueGap
    float top
    float bottom
    int bias
    box topBox
    box bottomBox

type trend
    int bias

type equalDisplay
    line l_ine = na
    label l_abel = na

type pivot
    float currentLevel
    float lastLevel
    bool crossed
    int barTime = time
    int barIndex = bar_index

type orderBlock
    float barHigh
    float barLow
    int barTime
    int bias

var pivot swingHigh = pivot.new(na, na, false)
var pivot swingLow = pivot.new(na, na, false)
var pivot internalHigh = pivot.new(na, na, false)
var pivot internalLow = pivot.new(na, na, false)
var pivot equalHigh = pivot.new(na, na, false)
var pivot equalLow = pivot.new(na, na, false)
var trend swingTrend = trend.new(0)
var trend internalTrend = trend.new(0)
var equalDisplay equalHighDisplay = equalDisplay.new()
var equalDisplay equalLowDisplay = equalDisplay.new()
var array<fairValueGap> fairValueGaps = array.new<fairValueGap>()
var array<float> parsedHighs = array.new<float>()
var array<float> parsedLows = array.new<float>()
var array<float> highs = array.new<float>()
var array<float> lows = array.new<float>()
var array<int> times = array.new<int>()
var trailingExtremes trailing = trailingExtremes.new()
var array<orderBlock> swingOrderBlocks = array.new<orderBlock>()
var array<orderBlock> internalOrderBlocks = array.new<orderBlock>()
var array<box> swingOrderBlocksBoxes = array.new<box>()
var array<box> internalOrderBlocksBoxes = array.new<box>()
var swingBullishColor = GREEN
var swingBearishColor = RED
var fairValueGapBullishColor = color.new(#00ff68, 70)
var fairValueGapBearishColor = color.new(#ff0008, 70)
varip int currentBarIndex = bar_index
varip int lastBarIndex = bar_index
alerts currentAlerts = alerts.new()

// --- DYNAMIC TIMEFRAME MAPPING ---
var string tf_ltf = "60" 
var string tf_htf = "D" 
var string tf_filter = "240" 
var bool is_tf_supported = false

if timeframe.isminutes
    if timeframe.multiplier == 60
        tf_ltf := "15"
        tf_htf := "240"
        tf_filter := "60"
        is_tf_supported := true
    else if timeframe.multiplier == 120
        tf_ltf := "30"
        tf_htf := "240"
        tf_filter := "120"
        is_tf_supported := true
    else if timeframe.multiplier == 180
        tf_ltf := "45"
        tf_htf := "D"
        tf_filter := "180"
        is_tf_supported := true
    else if timeframe.multiplier == 240
        tf_ltf := "60"
        tf_htf := "D"
        tf_filter := "240"
        is_tf_supported := true
else if timeframe.isdaily
    tf_ltf := "240"
    tf_htf := "W"
    tf_filter := "D"
    is_tf_supported := true
else if timeframe.isweekly
    tf_ltf := "D"
    tf_htf := "M"
    tf_filter := "W"
    is_tf_supported := true

safe_ltf = is_tf_supported ? tf_ltf : timeframe.period
safe_htf = is_tf_supported ? tf_htf : timeframe.period
safe_filter = is_tf_supported ? tf_filter : timeframe.period

// --- MARKET CONTEXT (ALICE'IN BEYNI) ---
[macdLine, signalLine, histLine] = ta.macd(macdSource, macdFast, macdSlow, macdSignal)
isBull = histLine >= 0

[_, _, histLineLTF] = request.security(syminfo.tickerid, safe_ltf, ta.macd(macdSource, macdFast, macdSlow, macdSignal))
isBull1H = histLineLTF >= 0 

[_, _, histLineHTF] = request.security(syminfo.tickerid, safe_htf, ta.macd(macdSource, macdFast, macdSlow, macdSignal), lookahead=barmerge.lookahead_on)
isDailyBull_raw = histLineHTF >= 0

// ==========================================
// QQE TREND CALCULATION
// ==========================================
f_getQQEDirection(_len, _smooth, _factor) =>
    _rsi = ta.rsi(close, _len) 
    _smoothedRsi = ta.ema(_rsi, _smooth)
    _atrRsi = math.abs(nz(_smoothedRsi[1], _smoothedRsi) - _smoothedRsi)
    _wilders = _len * 2 - 1
    _smoothedAtrRsi = ta.ema(_atrRsi, _wilders)
    _dynamicAtrRsi = _smoothedAtrRsi * _factor
    _trend = (_smoothedRsi - 50) > 0 ? 1 : -1
    _trend

// WALL STREET DATA FEED
trend_Yield = request.security("TVC:US10Y", safe_filter, f_getQQEDirection(qqeRsiLength, qqeRsiSmoothing, qqeFactor))
trend_DXY = request.security("TVC:DXY", safe_filter, f_getQQEDirection(qqeRsiLength, qqeRsiSmoothing, qqeFactor))
trend_VIX = request.security("TVC:VIX", safe_filter, f_getQQEDirection(qqeRsiLength, qqeRsiSmoothing, qqeFactor))
trend_SPX = request.security("SP:SPX", safe_filter, f_getQQEDirection(qqeRsiLength, qqeRsiSmoothing, qqeFactor))
trend_Tech = request.security("AMEX:XLK", safe_filter, f_getQQEDirection(qqeRsiLength, qqeRsiSmoothing, qqeFactor))
trend_SPX_Price = request.security("SP:SPX", safe_filter, f_getQQEDirection(qqeRsiLength, qqeRsiSmoothing, qqeFactor))

var bool d_isYield_Bull = false  
var bool d_isDXY_Bull = false    
var bool d_isVIX_Bull = false    
var bool d_isSPX_Bull = false    
var bool d_isTech_Bull = false   

// CANLI VERI (Her zaman update)
d_isYield_Bull := (trend_Yield == 1)
d_isDXY_Bull := (trend_DXY == 1)
d_isVIX_Bull := (trend_VIX == 1)
d_isSPX_Bull := (trend_SPX == 1)
d_isTech_Bull := (trend_Tech == 1)

vixClose = request.security("TVC:VIX", safe_filter, close)
isVixRising = vixClose > vixClose[1]
isVixFalling = vixClose < vixClose[1]
imf = ta.mfi(close, 14)
isImfRising = imf > imf[1]
isImfFalling = imf < imf[1]

bbLength = input.int(20, "BB Periyot", group=aliceGroup)
bbMult = input.float(2.0, "BB Std Sapma", group=aliceGroup)
basis = ta.sma(close, bbLength)
dev = bbMult * ta.stdev(close, bbLength)
upper = basis + dev
lower = basis - dev
bbWidth = (upper - lower) / basis
isHighVolatility = bbWidth > ta.sma(bbWidth, 20)

stochRsiFunc() =>
    rsi = ta.rsi(close, 14)
    stochRsi = ta.stoch(rsi, rsi, rsi, 14)
    stochRsiD = ta.sma(stochRsi, 3)
    [stochRsi, stochRsiD]
[stochRsi, stochRsiD] = stochRsiFunc()
isStochBuyCross = ta.crossover(stochRsi, 20)
isStochSellCross = ta.crossunder(stochRsi, 80)
ema8 = ta.ema(close, 8)
ema200 = ta.ema(close, 200)

var isBullishBreak = false
var isBearishBreak = false
isBullishBreak := false
isBearishBreak := false

if barstate.isfirst
    if showSwingOrderBlocksInput
        for index = 1 to swingOrderBlocksSizeInput
            swingOrderBlocksBoxes.push(box.new(na, na, na, na, xloc=xloc.bar_time, extend=extend.right))
    if showInternalOrderBlocksInput
        for index = 1 to internalOrderBlocksSizeInput
            internalOrderBlocksBoxes.push(box.new(na, na, na, na, xloc=xloc.bar_time, extend=extend.right))

bearishOrderBlockMitigationSource = orderBlockMitigationInput == CLOSE ? close : high
bullishOrderBlockMitigationSource = orderBlockMitigationInput == CLOSE ? close : low
atrMeasure = ta.atr(200)
volatilityMeasure = orderBlockFilterInput == ATR ? atrMeasure : ta.cum(ta.tr) / bar_index
highVolatilityBar = (high - low) >= (2 * volatilityMeasure)
parsedHigh = highVolatilityBar ? low : high
parsedLow = highVolatilityBar ? high : low
parsedHighs.push(parsedHigh)
parsedLows.push(parsedLow)
highs.push(high)
lows.push(low)
times.push(time)

// 3. YARDIMCI FONKSIYONLAR (SMC & DRAWING)
leg(int size) =>
    var leg = 0
    newLegHigh = high[size] > ta.highest(size)
    newLegLow = low[size] < ta.lowest(size)
    if newLegHigh
        leg := BEARISH_LEG
    else if newLegLow
        leg := BULLISH_LEG
    leg

startOfNewLeg(int leg) => ta.change(leg) != 0
startOfBearishLeg(int leg) => ta.change(leg) == -1
startOfBullishLeg(int leg) => ta.change(leg) == +1

getStyle(string style) =>
    switch style
        SOLID => line.style_solid
        DASHED => line.style_dashed
        DOTTED => line.style_dotted

drawLabel(int labelTime, float labelPrice, string tag, color labelColor, string labelStyle) =>
    var label l_abel = na
    l_abel.delete()
    l_abel := label.new(chart.point.new(labelTime, na, labelPrice), tag, xloc.bar_time, color=color(na), textcolor=labelColor, style=labelStyle, size=size.small)

drawEqualHighLow(pivot p_ivot, float level, int size, bool equalHigh) =>
    equalDisplay e_qualDisplay = equalHigh ? equalHighDisplay : equalLowDisplay
    string tag = 'EQL'
    color equalColor = swingBullishColor
    string labelStyle = label.style_label_up
    if equalHigh
        tag := 'EQH'
        equalColor := swingBearishColor
        labelStyle := label.style_label_down
    line.delete(e_qualDisplay.l_ine)
    label.delete(e_qualDisplay.l_abel)
    e_qualDisplay.l_ine := line.new(chart.point.new(p_ivot.barTime, na, p_ivot.currentLevel), chart.point.new(time[size], na, level), xloc=xloc.bar_time, color=equalColor, style=line.style_dotted)
    labelPosition = math.round(0.5 * (p_ivot.barIndex + bar_index - size))
    e_qualDisplay.l_abel := label.new(chart.point.new(na, labelPosition, level), tag, xloc.bar_index, color=color(na), textcolor=equalColor, style=labelStyle, size=TINY)

getCurrentStructure(int size, bool equalHighLow=false, bool internal=false) =>
    currentLeg = leg(size)
    newPivot = startOfNewLeg(currentLeg)
    pivotLow = startOfBullishLeg(currentLeg)
    pivotHigh = startOfBearishLeg(currentLeg)
    if newPivot
        if pivotLow
            pivot p_ivot = equalHighLow ? equalLow : internal ? internalLow : swingLow
            if equalHighLow and math.abs(p_ivot.currentLevel - low[size]) < equalHighsLowsThresholdInput * atrMeasure
                drawEqualHighLow(p_ivot, low[size], size, false)
            p_ivot.lastLevel := p_ivot.currentLevel
            p_ivot.currentLevel := low[size]
            p_ivot.crossed := false
            p_ivot.barTime := time[size]
            p_ivot.barIndex := bar_index[size]
            if not equalHighLow and not internal
                trailing.bottom := p_ivot.currentLevel
                trailing.barTime := p_ivot.barTime
                trailing.barIndex := p_ivot.barIndex
                trailing.lastBottomTime := p_ivot.barTime
            if showSwingsInput and not internal and not equalHighLow
                drawLabel(time[size], p_ivot.currentLevel, p_ivot.currentLevel < p_ivot.lastLevel ? 'LL' : 'HL', swingBullishColor, label.style_label_up)
        else
            pivot p_ivot = equalHighLow ? equalHigh : internal ? internalHigh : swingHigh
            if equalHighLow and math.abs(p_ivot.currentLevel - high[size]) < equalHighsLowsThresholdInput * atrMeasure
                drawEqualHighLow(p_ivot, high[size], size, true)
            p_ivot.lastLevel := p_ivot.currentLevel
            p_ivot.currentLevel := high[size]
            p_ivot.crossed := false
            p_ivot.barTime := time[size]
            p_ivot.barIndex := bar_index[size]
            if not equalHighLow and not internal
                trailing.top := p_ivot.currentLevel
                trailing.barTime := p_ivot.barTime
                trailing.barIndex := p_ivot.barIndex
                trailing.lastTopTime := p_ivot.barTime
            if showSwingsInput and not internal and not equalHighLow
                drawLabel(time[size], p_ivot.currentLevel, p_ivot.currentLevel > p_ivot.lastLevel ? 'HH' : 'LH', swingBearishColor, label.style_label_down)

drawStructure(pivot p_ivot, string tag, color structureColor, string lineStyleString, string labelStyle, string labelSize) =>
    var line l_ine = line.new(na, na, na, na, xloc=xloc.bar_time)
    var label l_abel = label.new(na, na)
    l_ine.delete()
    l_abel.delete()
    l_ine := line.new(chart.point.new(p_ivot.barTime, na, p_ivot.currentLevel), chart.point.new(time, na, p_ivot.currentLevel), xloc = xloc.bar_time, color=structureColor, style=getStyle(lineStyleString))
    l_abel := label.new(chart.point.new(na, math.round(0.5 * (p_ivot.barIndex + bar_index)), p_ivot.currentLevel), tag, xloc.bar_index, color=color(na), textcolor=structureColor, style=labelStyle, size=labelSize)

deleteOrderBlocks(bool internal=false) =>
    array<orderBlock> orderBlocks = internal ? internalOrderBlocks : swingOrderBlocks
    if orderBlocks.size() > 0
        for i = orderBlocks.size() - 1 to 0
            eachOrderBlock = orderBlocks.get(i)
            bool crossedOderBlock = false
            if bearishOrderBlockMitigationSource > eachOrderBlock.barHigh and eachOrderBlock.bias == BEARISH
                crossedOderBlock := true
                if internal
                    currentAlerts.internalBearishOrderBlock := true
                else
                    currentAlerts.swingBearishOrderBlock := true
            else if bullishOrderBlockMitigationSource < eachOrderBlock.barLow and eachOrderBlock.bias == BULLISH
                crossedOderBlock := true
                if internal
                    currentAlerts.internalBullishOrderBlock := true
                else
                    currentAlerts.swingBullishOrderBlock := true
            if crossedOderBlock
                orderBlocks.remove(i)

storeOrdeBlock(pivot p_ivot, bool internal=false, int bias) =>
    if (not internal and showSwingOrderBlocksInput) or (internal and showInternalOrderBlocksInput)
        array<float> a_rray = na
        int parsedIndex = na
        if bias == BEARISH
            a_rray := parsedHighs.slice(p_ivot.barIndex, bar_index)
            parsedIndex := p_ivot.barIndex + a_rray.indexof(a_rray.max())
        else
            a_rray := parsedLows.slice(p_ivot.barIndex, bar_index)
            parsedIndex := p_ivot.barIndex + a_rray.indexof(a_rray.min())
        orderBlock o_rderBlock = orderBlock.new(parsedHighs.get(parsedIndex), parsedLows.get(parsedIndex), times.get(parsedIndex), bias)
        array<orderBlock> orderBlocks = internal ? internalOrderBlocks : swingOrderBlocks
        if orderBlocks.size() >= 100
            orderBlocks.pop()
        orderBlocks.unshift(o_rderBlock)

drawOrderBlocks(bool internal=false) =>
    array<orderBlock> orderBlocks = internal ? internalOrderBlocks : swingOrderBlocks
    orderBlocksSize = orderBlocks.size()
    if orderBlocksSize > 0
        maxOrderBlocks = internal ? internalOrderBlocksSizeInput : swingOrderBlocksSizeInput
        array<orderBlock> parsedOrdeBlocks = orderBlocks.slice(0, math.min(maxOrderBlocks, orderBlocksSize))
        array<box> b_oxes = internal ? internalOrderBlocksBoxes : swingOrderBlocksBoxes
        for [index, eachOrderBlock] in parsedOrdeBlocks
            orderBlockColor = internal ? (eachOrderBlock.bias == BEARISH ? color.new(#f77c80, 80) : color.new(#3179f5, 80)) : (eachOrderBlock.bias == BEARISH ? color.new(#b22833, 80) : color.new(#1848cc, 80))
            box b_ox = b_oxes.get(index)
            b_ox.set_top_left_point(chart.point.new(eachOrderBlock.barTime, na, eachOrderBlock.barHigh))
            b_ox.set_bottom_right_point(chart.point.new(last_bar_time, na, eachOrderBlock.barLow))
            b_ox.set_border_color(internal ? na : orderBlockColor)
            b_ox.set_bgcolor(orderBlockColor)

displayStructure(bool internal=false) =>
    var bullishBar = true
    var bearishBar = true
    if internalFilterConfluenceInput
        bullishBar := high - math.max(close, open) > math.min(close, open - low)
        bearishBar := high - math.max(close, open) < math.min(close, open - low)
    pivot p_ivot = internal ? internalHigh : swingHigh
    trend t_rend = internal ? internalTrend : swingTrend
    string lineStyle = internal ? DASHED : SOLID
    string labelSize = internal ? TINY : SMALL
    bool extraCondition = internal ? internalHigh.currentLevel != swingHigh.currentLevel and bullishBar : true
    color bullishColor = internal ? internalBullColorInput : swingBullColorInput
    if ta.crossover(close, p_ivot.currentLevel) and not p_ivot.crossed and extraCondition
        string tag = t_rend.bias == BEARISH ? CHOCH : BOS
        if internal
            currentAlerts.internalBullishCHoCH := tag == CHOCH
            currentAlerts.internalBullishBOS := tag == BOS
        else
            currentAlerts.swingBullishCHoCH := tag == CHOCH
            currentAlerts.swingBullishBOS := tag == BOS
        p_ivot.crossed := true
        t_rend.bias := BULLISH
        bool displayCondition = internal ? (showInternalsInput and (showInternalBullInput == ALL or (showInternalBullInput == BOS and tag != CHOCH) or (showInternalBullInput == CHOCH and tag == CHOCH))) : (showStructureInput and (showSwingBullInput == ALL or (showSwingBullInput == BOS and tag != CHOCH) or (showSwingBullInput == CHOCH and tag == CHOCH)))
        if displayCondition
            drawStructure(p_ivot, tag, bullishColor, lineStyle, label.style_label_down, labelSize)
        if (internal and showInternalOrderBlocksInput) or (not internal and showSwingOrderBlocksInput)
            storeOrdeBlock(p_ivot, internal, BULLISH)
    p_ivot := internal ? internalLow : swingLow
    extraCondition := internal ? internalLow.currentLevel != swingLow.currentLevel and bearishBar : true
    bearishColor = internal ? internalBearColorInput : swingBearColorInput
    if ta.crossunder(close, p_ivot.currentLevel) and not p_ivot.crossed and extraCondition
        string tag = t_rend.bias == BULLISH ? CHOCH : BOS
        if internal
            currentAlerts.internalBearishCHoCH := tag == CHOCH
            currentAlerts.internalBearishBOS := tag == BOS
        else
            currentAlerts.swingBearishCHoCH := tag == CHOCH
            currentAlerts.swingBearishBOS := tag == BOS
        p_ivot.crossed := true
        t_rend.bias := BEARISH
        displayCondition = internal ? showInternalsInput and (showInternalBearInput == ALL or (showInternalBearInput == BOS and tag != CHOCH) or (showInternalBearInput == CHOCH and tag == CHOCH)) : showStructureInput and (showSwingBearInput == ALL or (showSwingBearInput == BOS and tag != CHOCH) or (showSwingBearInput == CHOCH and tag == CHOCH))
        if displayCondition
            drawStructure(p_ivot, tag, bearishColor, lineStyle, label.style_label_up, labelSize)
        if (internal and showInternalOrderBlocksInput) or (not internal and showSwingOrderBlocksInput)
            storeOrdeBlock(p_ivot, internal, BEARISH)

fairValueGapBox(leftTime, rightTime, topPrice, bottomPrice, boxColor) => box.new(chart.point.new(leftTime, na, topPrice), chart.point.new(rightTime + fairValueGapsExtendInput * (time - time[1]), na, bottomPrice), xloc=xloc.bar_time, border_color=boxColor, bgcolor=boxColor)

deleteFairValueGaps() =>
    if fairValueGaps.size() > 0
        for i = fairValueGaps.size() - 1 to 0
            eachFairValueGap = fairValueGaps.get(i)
            if (low < eachFairValueGap.bottom and eachFairValueGap.bias == BULLISH) or (high > eachFairValueGap.top and eachFairValueGap.bias == BEARISH)
                eachFairValueGap.topBox.delete()
                eachFairValueGap.bottomBox.delete()
                fairValueGaps.remove(i)

drawFairValueGaps() =>
    [lastClose, lastOpen, lastTime, currentHigh, currentLow, currentTime, last2High, last2Low] = request.security(syminfo.tickerid, fairValueGapsTimeframeInput, [close[1], open[1], time[1], high[0], low[0], time[0], high[2], low[2]], lookahead=barmerge.lookahead_on)
    barDeltaPercent = (lastClose - lastOpen) / (lastOpen * 100)
    newTimeframe = timeframe.change(fairValueGapsTimeframeInput)
    threshold = fairValueGapsThresholdInput ? ta.cum(math.abs(newTimeframe ? barDeltaPercent : 0)) / bar_index * 2 : 0
    bullishFairValueGap = currentLow > last2High and lastClose > last2High and barDeltaPercent > threshold and newTimeframe
    bearishFairValueGap = currentHigh < last2Low and lastClose < last2Low and -barDeltaPercent > threshold and newTimeframe
    if bullishFairValueGap
        currentAlerts.bullishFairValueGap := true
        fairValueGaps.unshift(fairValueGap.new(currentLow, last2High, BULLISH, fairValueGapBox(lastTime, currentTime, currentLow, math.avg(currentLow, last2High), fairValueGapBullishColor), fairValueGapBox(lastTime, currentTime, math.avg(currentLow, last2High), last2High, fairValueGapBullishColor)))
    if bearishFairValueGap
        currentAlerts.bearishFairValueGap := true
        fairValueGaps.unshift(fairValueGap.new(currentHigh, last2Low, BEARISH, fairValueGapBox(lastTime, currentTime, currentHigh, math.avg(currentHigh, last2Low), fairValueGapBearishColor), fairValueGapBox(lastTime, currentTime, math.avg(currentHigh, last2Low), last2Low, fairValueGapBearishColor)))

updateTrailingExtremes() =>
    trailing.top := math.max(high, trailing.top)
    trailing.lastTopTime := trailing.top == high ? time : trailing.lastTopTime
    trailing.bottom := math.min(low, trailing.bottom)
    trailing.lastBottomTime := trailing.bottom == low ? time : trailing.lastBottomTime

drawHighLowSwings() =>
    var line topLine = line.new(na, na, na, na, color=swingBearishColor, xloc=xloc.bar_time)
    var line bottomLine = line.new(na, na, na, na, color=swingBullishColor, xloc=xloc.bar_time)
    var label topLabel = label.new(na, na, color=color(na), textcolor=swingBearishColor, xloc=xloc.bar_time, style=label.style_label_down, size=size.tiny)
    var label bottomLabel = label.new(na, na, color=color(na), textcolor=swingBullishColor, xloc=xloc.bar_time, style=label.style_label_up, size=size.tiny)
    rightTimeBar = last_bar_time + 20 * (time - time[1])
    topLine.set_first_point(chart.point.new(trailing.lastTopTime, na, trailing.top))
    topLine.set_second_point(chart.point.new(rightTimeBar, na, trailing.top))
    topLabel.set_point(chart.point.new(rightTimeBar, na, trailing.top))
    topLabel.set_text(swingTrend.bias == BEARISH ? 'Strong High' : 'Weak High')
    bottomLine.set_first_point(chart.point.new(trailing.lastBottomTime, na, trailing.bottom))
    bottomLine.set_second_point(chart.point.new(rightTimeBar, na, trailing.bottom))
    bottomLabel.set_point(chart.point.new(rightTimeBar, na, trailing.bottom))
    bottomLabel.set_text(swingTrend.bias == BULLISH ? 'Strong Low' : 'Weak Low')

isInOrderBlock(int bias) =>
    var bool inBlock = false
    array<orderBlock> orderBlocks = swingOrderBlocks
    if array.size(orderBlocks) > 0
        int limit = math.min(array.size(orderBlocks), swingOrderBlocksSizeInput)
        for i = 0 to limit - 1
            orderBlock ob = array.get(orderBlocks, i)
            if ob.bias == bias and close >= ob.barLow and close <= ob.barHigh
                inBlock := true
                break
    inBlock

// 4. DIGER INDIKATORLER (ZLT, QQE, VIDYA)
atr = ta.atr(14)
scaledAtr = atr 

srBandFactorAuto() =>
    float f = 0.25
    if timeframe.isintraday
        if timeframe.multiplier <= 5
            f := 0.5
        else if timeframe.multiplier <= 15
            f := 0.4
        else if timeframe.multiplier <= 30
            f := 0.35
        else if timeframe.multiplier <= 60
            f := 0.3
        else if timeframe.multiplier <= 120
            f := 0.20
        else if timeframe.multiplier <= 240
            f := 0.16
        else
            f := 0.13
    else
        f := 0.12
    f
var float sr_band_factor = srBandFactorAuto()

// ZERO LAG TREND
zltSrc = close
zltLag = math.floor((zltLength - 1) / 2)
zltZlema = ta.ema(zltSrc + (zltSrc - nz(zltSrc[zltLag], zltSrc)), zltLength)
zltVolatility = ta.highest(ta.atr(zltLength), math.max(1, zltLength * 3)) * zltMult
var int zltTrend = 0
if ta.crossover(close, zltZlema + zltVolatility)
    zltTrend := 1
if ta.crossunder(close, zltZlema - zltVolatility)
    zltTrend := -1
isZltBullish = zltTrend == 1
isZltBearish = zltTrend == -1
isZltBullishTrendChange = ta.crossover(zltTrend, 0)
isZltBearishTrendChange = ta.crossunder(zltTrend, 0)

// QQE MOD (CHART VISUAL)
calculateQQE(rsiLength, smoothingFactor, qqeFactor, source) =>
    wildersLength = rsiLength * 2 - 1
    rsi = ta.rsi(source, rsiLength)
    smoothedRsi = ta.ema(rsi, smoothingFactor)
    atrRsi = math.abs(nz(smoothedRsi[1], smoothedRsi) - smoothedRsi)
    smoothedAtrRsi = ta.ema(atrRsi, wildersLength)
    dynamicAtrRsi = smoothedAtrRsi * qqeFactor
    var float longBand = na
    var float shortBand = na
    var int trendDirection = 0
    trendDirection := nz(trendDirection[1], 0)
    float atrDelta = dynamicAtrRsi
    float newShortBand = smoothedRsi + atrDelta
    float newLongBand = smoothedRsi - atrDelta
    float prevLong = nz(longBand[1], newLongBand)
    float prevShort = nz(shortBand[1], newShortBand)
    longBand := (nz(smoothedRsi[1], smoothedRsi) > prevLong and smoothedRsi > prevLong) ? math.max(prevLong, newLongBand) : newLongBand
    shortBand := (nz(smoothedRsi[1], smoothedRsi) < prevShort and smoothedRsi < prevShort) ? math.min(prevShort, newShortBand) : newShortBand
    if ta.crossover(smoothedRsi, prevShort)
        trendDirection := 1
    else if ta.crossunder(smoothedRsi, prevLong)
        trendDirection := -1
    else
        trendDirection := nz(trendDirection[1], 0)
    qqeTrendLine = trendDirection == 1 ? longBand : shortBand
    [qqeTrendLine, smoothedRsi, trendDirection]
[qqeTrendLine, qqeRsiLine, localQQETrend] = calculateQQE(qqeRsiLength, qqeRsiSmoothing, qqeFactor, qqeSource)
isQQEBullishCross = ta.crossover(qqeRsiLine - 50, 0)
isQQEBearishCross = ta.crossunder(qqeRsiLine - 50, 0)

// VOLUMATIC VIDYA
var float local_vidya_value = na
vidya_calc(src, vidya_length_, vidya_momentum_) =>
    float momentum = ta.change(src)
    float sum_pos_momentum = math.sum(momentum >= 0 ? momentum : 0.0, vidya_momentum_)
    float sum_neg_momentum = math.sum(momentum >= 0 ? 0.0 : -momentum, vidya_momentum_)
    float denom = sum_pos_momentum + sum_neg_momentum
    float abs_cmo = denom != 0 ? math.abs(100 * (sum_pos_momentum - sum_neg_momentum) / denom) : 0.0
    float alpha = 2 / (vidya_length_ + 1)
    float k = alpha * abs_cmo / 100
    var float local_vidya_value = nz(local_vidya_value[1], src)
    local_vidya_value := k * src + (1 - k) * nz(local_vidya_value[1], src)
    ta.sma(local_vidya_value, 15)
var float vidya_value = na
vidya_value := vidya_calc(close, vidya_length, vidya_momentum)
vidya_upper_band = vidya_value + scaledAtr * band_distance
vidya_lower_band = vidya_value - scaledAtr * band_distance
var bool is_vidya_trend_up = false
is_vidya_trend_up := nz(is_vidya_trend_up[1], false)
if ta.crossover(close, vidya_upper_band)
    is_vidya_trend_up := true
if ta.crossunder(close, vidya_lower_band)
    is_vidya_trend_up := false
isVidyaBullishCross = not nz(is_vidya_trend_up[1], false) and is_vidya_trend_up
isVidyaBearishCross = nz(is_vidya_trend_up[1], false) and not is_vidya_trend_up
var float vidya_up_trend_volume = 0.0
vidya_up_trend_volume := nz(vidya_up_trend_volume[1], 0.0)
var float vidya_down_trend_volume = 0.0
vidya_down_trend_volume := nz(vidya_down_trend_volume[1], 0.0)
if ta.change(is_vidya_trend_up)
    vidya_up_trend_volume := 0.0
    vidya_down_trend_volume := 0.0
else
    vidya_up_trend_volume := vidya_up_trend_volume + (close > open ? volume : 0)
    vidya_down_trend_volume := vidya_down_trend_volume + (close < open ? volume : 0)
avg_volume_delta = (vidya_up_trend_volume + vidya_down_trend_volume) / 2
vidya_delta_volume_percent = avg_volume_delta != 0 ? math.abs(vidya_up_trend_volume - vidya_down_trend_volume) / avg_volume_delta * 100 : 0
var bool is_low_delta_period = vidya_delta_volume_percent <= 10

var bool zltBullCredit = false
var bool zltBearCredit = false
var bool vidyaBullCredit = false
var bool vidyaBearCredit = false

if isZltBullishTrendChange
    zltBullCredit := true
    zltBearCredit := false
if isZltBearishTrendChange
    zltBearCredit := true
    zltBullCredit := false

if isVidyaBullishCross
    vidyaBullCredit := true
    vidyaBearCredit := false
if isVidyaBearishCross
    vidyaBearCredit := true
    vidyaBullCredit := false

var bool smcSwingBullBias = false
var bool smcSwingBearBias = false

// 5. PUANLAMA SISTEMI (SCORING) - ALICE VERSIYONU
calculateScore(isBuy) =>
    float score = 0
    string details = ""
    
    if isBuy
        if close > nz(ema8, close)
            score += 5
            details := details + "Fiyat > EMA8 (+5)\n"
        if close > nz(ema200, close)
            score += 5
            details := details + "Fiyat > EMA200 (+5)\n"
        
        if nz(ema8, 0) > nz(ema200, 0)
            score += 15
            details := details + "EMA Trendi (GC) (+15)\n"

        if nz(histLine[1], histLine) < 0 and histLine > 0 and histLine > nz(histLine[1], histLine) and histLine > 0.05
            score += 10
            details := details + "MACD Al (+10)\n"
        if nz(close[1], close) < nz(ema8[1], ema8) and close > nz(ema8, close)
            score += 5
            details := details + "EMA8 Kirilim (+5)\n"
        if nz(close[1], close) < nz(ema200[1], ema200) and close > nz(ema200, close)
            score += 10
            details := details + "EMA200 Kirilim (+10)\n"
        
        if isBull and isBull1H and isDailyBull_raw
            score += 15
            details := details + "Full Timeframe Bull (+15)\n"
        else if isBull and isBull1H
            score += 10
            details := details + "LTF+Curr Bull (+10)\n"
            
        if zltBullCredit
            score += 40
            details := details + "ZLT Trendi (+40)\n"

        if vidyaBullCredit
            score += 10
            details := details + "Vidya Trendi (+10)\n"

        if vidya_delta_volume_percent > 30
            score += 5
        if vidya_delta_volume_percent > 50
            score += 10
        if isHighVolatility
            score += 5
        if isImfRising
            score += 10
            details := details + "MFI Artiyor (+10)\n"
        if isQQEBullishCross
            score += 20
            details := details + "QQE Cross (+20)\n"
        if isStochBuyCross
            score += 10
            details := details + "Stoch Al (+10)\n"
        if isBullishBreak
            score += 5
            details := details + "Direnc Kirilimi (+5)\n"
    else
        if close < nz(ema8, close)
            score += 5
            details := details + "Fiyat < EMA8 (+5)\n"
        if close < nz(ema200, close)
            score += 5
            details := details + "Fiyat < EMA200 (+5)\n"
        
        if nz(ema8, 0) < nz(ema200, 0)
            score += 15
            details := details + "EMA Trendi (DC) (+15)\n"

        if nz(histLine[1], histLine) > 0 and histLine < 0 and histLine < nz(histLine[1], histLine) and histLine < -0.05
            score += 10
            details := details + "MACD Sat (+10)\n"
        if nz(close[1], close) > nz(ema8[1], ema8) and close < nz(ema8, close)
            score += 5
            details := details + "EMA8 Asagi Kirilim (+5)\n"
        if nz(close[1], close) > nz(ema200[1], ema200) and close < nz(ema200, close)
            score += 10
            details := details + "EMA200 Asagi Kirilim (+10)\n"
        
        if (not isBull) and (not isBull1H) and (not isDailyBull_raw)
            score += 15
            details := details + "Full Timeframe Bear (+15)\n"
        else if (not isBull) and (not isBull1H)
            score += 10
            details := details + "LTF+Curr Bear (+10)\n"
        
        if zltBearCredit
            score += 40
            details := details + "ZLT Trendi (+40)\n"

        if vidyaBearCredit
            score += 10
            details := details + "Vidya Trendi (+10)\n"

        if vidya_delta_volume_percent > 30
            score += 5
        if vidya_delta_volume_percent > 50
            score += 10
        if isHighVolatility
            score += 5
        if isImfFalling
            score += 10
            details := details + "MFI Dusuyor (+10)\n"
        if isQQEBearishCross
            score += 20
            details := details + "QQE Cross (+20)\n"
        if isStochSellCross
            score += 10
            details := details + "Stoch Sat (+10)\n"
        if isBearishBreak
            score += 5
            details := details + "Destek Kirilimi (+5)\n"
   
    if isBuy
        if smcSwingBullBias
            score += 20
            details := details + "Swing Market Structure (+20)\n"
        
        if currentAlerts.swingBullishBOS
            score += 20
            details := details + "Swing BOS (+20)\n"
        if currentAlerts.internalBullishCHoCH
            score += 15
            details := details + "Int CHoCH (+15)\n"
        if currentAlerts.internalBullishBOS
            score += 10
            details := details + "Int BOS (+10)\n"
        if currentAlerts.bullishFairValueGap
            score += 10
            details := details + "FVG (+10)\n"
        if isInOrderBlock(BULLISH)
            score += 10
            details := details + "Order Block (+10)\n"
        if currentAlerts.equalLows
            score += 5
            details := details + "EQL (+5)\n"
    else
        if smcSwingBearBias
            score += 20
            details := details + "Swing Market Structure (+20)\n"

        if currentAlerts.swingBearishBOS
            score += 20
            details := details + "Swing BOS (+20)\n"
        if currentAlerts.internalBearishCHoCH
            score += 15
            details := details + "Int CHoCH (+15)\n"
        if currentAlerts.internalBearishBOS
            score += 10
            details := details + "Int BOS (+10)\n"
        if currentAlerts.bearishFairValueGap
            score += 10
            details := details + "FVG (+10)\n"
        if isInOrderBlock(BEARISH)
            score += 10
            details := details + "Order Block (+10)\n"
        if currentAlerts.equalHighs
            score += 10
            details := details + "EQH (+10)\n"

    // TREND FILTRESI (ALICE OZEL: SPX TRENDI)
    bool isIndex = syminfo.tickerid == "SP:SPX" or syminfo.tickerid == "NASDAQ:NDX"
    if not isIndex
        if trend_SPX_Price == -1 
            if isBuy
                score := score - 0 
            else
                score := score + 15 
                details := details + "SPX Bear (+15)\n"
        else if trend_SPX_Price == 1
            if isBuy
                score := score + 15
                details := details + "SPX Bull (+15)\n"
    
    // PIYASA KONTEKSTI (ALICE MANTIGI)
    if isBuy
        if d_isTech_Bull and not isIndex
            score += 10
            details := details + "Tech Sector Bull (+10)\n"
        if d_isSPX_Bull and d_isTech_Bull
            score += 10
            details := details + "SPX+Tech Rally (+10)\n"
        if not d_isDXY_Bull
            score += 10
            details := details + "Dolar Zayif (+10)\n"
        if not d_isYield_Bull
            score += 10
            details := details + "Faizler Dusuyor (+10)\n"
    else
        if (not d_isTech_Bull) and not isIndex
            score += 10
            details := details + "Tech Sector Bear (+10)\n"
        if d_isDXY_Bull
            score += 10
            details := details + "Dolar Guclu (+10)\n"
        if d_isYield_Bull
            score += 10
            details := details + "Faizler Artiyor (+10)\n"      
    if isBuy and isVixFalling
        score += 10
        details := details + "VIX Dusuyor (+10)\n"
    if not isBuy and isVixRising
        score += 10
        details := details + "VIX Yukseliyor (+10)\n"

    if is_low_delta_period
        score := score - 10
        details := details + "Low Vol (-10)\n"
    
    [score, details]

// 6. LOGIC EXECUTION (SMC & DRAWING LOOPS)
if is_tf_supported
    // SMC Main Logic
    getCurrentStructure(swingsLengthInput, false)
    getCurrentStructure(5, false, true)

    getCurrentStructure(equalHighsLowsLengthInput, true)

    displayStructure(true)
    displayStructure()

    if currentAlerts.swingBullishCHoCH
        smcSwingBullBias := true
        smcSwingBearBias := false

    if currentAlerts.swingBearishCHoCH
        smcSwingBearBias := true
        smcSwingBullBias := false
    // ==========================================

    if showInternalOrderBlocksInput
        deleteOrderBlocks(true)

    if showSwingOrderBlocksInput
        deleteOrderBlocks()

    if showFairValueGapsInput
        drawFairValueGaps()

    if barstate.islastconfirmedhistory or barstate.islast
        if showInternalOrderBlocksInput
            drawOrderBlocks(true)
        if showSwingOrderBlocksInput
            drawOrderBlocks()

    if showHighLowSwingsInput
        updateTrailingExtremes()
        drawHighLowSwings()

    if showFairValueGapsInput
        deleteFairValueGaps()

// DEGISKEN GUNCELLEMELERI
lastBarIndex := currentBarIndex
currentBarIndex := bar_index
newBar = currentBarIndex != lastBarIndex
var float bandBasePercent = 0.10
bandBasePercent := na(bandBasePercent[1]) ? 0.10 : bandBasePercent[1]

// ====== S/R BANDS LOGIC ======
var array<float> supportLevels = array.new<float>()
var array<box> supportBoxes = array.new<box>()
var array<int> supportAges = array.new<int>()
var array<label> supportLabels = array.new<label>()

var array<float> resistanceLevels = array.new<float>()
var array<box> resistanceBoxes = array.new<box>()
var array<int> resistanceAges = array.new<int>()
var array<label> resistanceLabels = array.new<label>()

ph = ta.pivothigh(high, leftBars, rightBars)
pl = ta.pivotlow(low, leftBars, rightBars)

getBandPercent(level) =>
    float safeLevel = math.max(math.abs(level), 1e-8)
    float atrPart = (scaledAtr / safeLevel) * 100
    float combinedPercent = nz(bandBasePercent, 0.10) + atrPart
    float maxPercent = 0.3 
    math.min(maxPercent, math.max(0.1, combinedPercent))

getBandBounds(level) =>
    float upperBand = level + scaledAtr * sr_band_factor
    float lowerBand = level - scaledAtr * sr_band_factor
    [upperBand, lowerBand]

isOverlapping(newUpper, newLower, float[] levels) =>
    if array.size(levels) > 0
        bool result = false
        for i = 0 to array.size(levels) - 1
            float lvl = array.get(levels, i)
            [uBand, lBand] = getBandBounds(lvl)
            if not (newLower > uBand or newUpper < lBand)
                result := true
                break
        result
    else
        false

if is_tf_supported and showSRBands
    if not na(ph)
        [upBand, lowBand] = getBandBounds(ph)
        if not isOverlapping(upBand, lowBand, resistanceLevels)
            b = box.new(left = bar_index - rightBars - 3, top = upBand, right = bar_index, bottom = lowBand, xloc = xloc.bar_index, bgcolor = color.new(color.red, 85), border_color = color.new(color.red, 0))
            box.set_extend(b, extend.right)
            midPriceR = (upBand + lowBand) / 2
            futureIndexR = bar_index + 500
            lblR = label.new(x = futureIndexR, y = midPriceR, text = str.tostring(midPriceR, "#.##"), xloc = xloc.bar_index, yloc = yloc.price, style = label.style_label_right, textcolor = color.white, color = color.new(color.red, 100), size = size.small)
            array.push(resistanceLevels, ph)
            array.push(resistanceBoxes, b)
            array.push(resistanceAges, bar_index)
            array.push(resistanceLabels, lblR)

    if not na(pl)
        [upBand, lowBand] = getBandBounds(pl)
        if not isOverlapping(upBand, lowBand, supportLevels)
            b = box.new(left = bar_index - rightBars - 3, top = upBand, right = bar_index, bottom = lowBand, xloc = xloc.bar_index, bgcolor = color.new(color.green, 85), border_color = color.new(color.green, 0))
            box.set_extend(b, extend.right)
            midPrice = (upBand + lowBand) / 2
            futureIndex = bar_index + 500
            lbl = label.new(x = futureIndex, y = midPrice, text = str.tostring(midPrice, "#.##"), xloc = xloc.bar_index, yloc = yloc.price, style = label.style_label_right, textcolor = color.white, color = color.new(color.green, 100), size = size.small)
            array.push(supportLevels, pl)
            array.push(supportBoxes, b)
            array.push(supportAges, bar_index)
            array.push(supportLabels, lbl)

// Clean up old/broken SR bands
if (not showSRBands) or (not is_tf_supported)
    if array.size(supportBoxes) > 0
        for i = array.size(supportBoxes) - 1 to 0
            box.delete(array.get(supportBoxes, i))
            label.delete(array.get(supportLabels, i))
    array.clear(supportLevels)
    array.clear(supportBoxes)
    array.clear(supportAges)
    array.clear(supportLabels)
    if array.size(resistanceBoxes) > 0
        for i = array.size(resistanceBoxes) - 1 to 0
            box.delete(array.get(resistanceBoxes, i))
            label.delete(array.get(resistanceLabels, i))
    array.clear(resistanceLevels)
    array.clear(resistanceBoxes)
    array.clear(resistanceAges)
    array.clear(resistanceLabels)

if is_tf_supported and array.size(supportLevels) > 0
    for i = array.size(supportLevels) - 1 to 0
        lvl = array.get(supportLevels, i)
        age = bar_index - array.get(supportAges, i)
        [upBand, lowBand] = getBandBounds(lvl)
        bool isBroken = close < lowBand
        bool isOld = age > maxAgeBars
        if isBroken 
            isBearishBreak := true 
            if showBreakLabels
                label.new(x = bar_index, y = low + scaledAtr*2, text = "B", xloc = xloc.bar_index, style = label.style_label_down, color = color.new(#ffffff, 0), textcolor = color.rgb(0, 0, 0), size = size.tiny)
        if isBroken or isOld
            box.delete(array.get(supportBoxes, i))
            label.delete(array.get(supportLabels, i))
            array.remove(supportLevels, i)
            array.remove(supportBoxes, i)
            array.remove(supportAges, i)
            array.remove(supportLabels, i)

if is_tf_supported and array.size(resistanceLevels) > 0
    for i = array.size(resistanceLevels) - 1 to 0
        lvl = array.get(resistanceLevels, i)
        age = bar_index - array.get(resistanceAges, i)
        [upBand, lowBand] = getBandBounds(lvl)
        bool isBroken = close > upBand
        bool isOld = age > maxAgeBars
        if isBroken
            isBullishBreak := true 
            if showBreakLabels
                label.new(x = bar_index, y = high - scaledAtr*2, text = "B", xloc = xloc.bar_index, style = label.style_label_up, color = color.new(#ffffff, 0), textcolor = color.rgb(0, 0, 0), size = size.tiny)
        if isBroken or isOld
            box.delete(array.get(resistanceBoxes, i))
            label.delete(array.get(resistanceLabels, i))
            array.remove(resistanceLevels, i)
            array.remove(resistanceBoxes, i)
            array.remove(resistanceAges, i)
            array.remove(resistanceLabels, i)

// ==========================================
// 7. SINYAL VE TP/SL YONETIMI
// ==========================================
var float totalSignals = 0.0
totalSignals := nz(totalSignals[1], 0.0)
var float correctSignals = 0.0
correctSignals := nz(correctSignals[1], 0.0)
var int lastBuySignalBar = na
var int lastSellSignalBar = na
var float lastBuySignalPrice = na
var float lastSellSignalPrice = na
var float lastTPPrice = na
var float lastSLPrice = na
var bool isLastSignalBuy = na
var bool isSignalActive = false
isSignalActive := nz(isSignalActive[1], false)

var bool monitoringTrend = false
var bool monitoringIsBuy = false
var float monitoringEntryPrice = 0.0
var int totalExitSignals = 0
var int correctExitSignals = 0
var float totalProfitPercent = 0.0
var int lastTradeDirection = 0 

// --- TRAILING VARIABLES (HYBRID EXIT) ---
var float highestHighSinceEntry = na
var float lowestLowSinceEntry = na
var float trailLevelForPlot = na 

var array<line> currentLines = array.new_line()
var array<label> currentLabels = array.new_label()

clearOldLines() =>
    if array.size(currentLines) > 0
        for i = 0 to array.size(currentLines) - 1
            line.delete(array.get(currentLines, i))
    array.clear(currentLines)
    if array.size(currentLabels) > 0
        for i = 0 to array.size(currentLabels) - 1
            label.delete(array.get(currentLabels, i))
    array.clear(currentLabels)

deleteSpecificLines(array<line> lines, array<label> labels) =>
    if array.size(lines) > 0
        for i = 0 to array.size(lines) - 1
            line.delete(array.get(lines, i))
    if array.size(labels) > 0
        for i = 0 to array.size(labels) - 1
            label.delete(array.get(labels, i))

getNearestNLevels(float[] levelsArr, float entryPrice, int n, bool wantAbove) =>
    result = array.new_float()
    len = array.size(levelsArr)
    if len > 0
        candidates = array.new_float()
        dists = array.new_float()
        for i = 0 to len - 1
            lvl = array.get(levelsArr, i)
            cond = wantAbove ? (lvl > entryPrice) : (lvl < entryPrice)
            if cond
                array.push(candidates, lvl)
                array.push(dists, math.abs(lvl - entryPrice))
        
        candSize = array.size(candidates)
        if candSize > 0
            toTake = math.min(n, candSize)
            if toTake > 0
                for k = 0 to toTake - 1
                    if array.size(dists) == 0
                        break 
                    minIdx = 0
                    minVal = array.get(dists, 0)
                    if array.size(dists) > 1
                        for j = 1 to array.size(dists) - 1
                            dj = array.get(dists, j)
                            if dj < minVal
                                minVal := dj
                                minIdx := j
                    
                    array.push(result, array.get(candidates, minIdx))
                    array.remove(candidates, minIdx)
                    array.remove(dists, minIdx)
    result

drawTPAndSLAndReturnLines(isBuySignal, entryPrice, supportLevels_arr, resistanceLevels_arr, orderBlocks_arr) =>
    tpSlLines = array.new_line()
    tpSlLabels = array.new_label()
    sortedTpLevels = array.new_float()
    float tp1Level = na
    float slLevel = na

    if isBuySignal
        float sl_SR = na
        nearestSupports = getNearestNLevels(supportLevels_arr, entryPrice, 1, false)
        if array.size(nearestSupports) > 0
            float supPivot = array.get(nearestSupports, 0)
            [supU, supL] = getBandBounds(supPivot)
            sl_SR := supL
        float sl_ATR = entryPrice - (scaledAtr * atrSLMultiplier)
        if na(sl_SR)
            slLevel := sl_ATR
        else
            slLevel := math.max(sl_SR, sl_ATR)

        nearestRes = getNearestNLevels(resistanceLevels_arr, entryPrice, 3, true)
        if array.size(nearestRes) > 0
            for k = 0 to array.size(nearestRes) - 1
                float resPivot = array.get(nearestRes, k)
                [resU, resL] = getBandBounds(resPivot) 
                array.push(sortedTpLevels, resL) 
        
        float mainTPLevel = na
        if array.size(orderBlocks_arr) > 0
            mainTPLevel := array.get(orderBlocks_arr, 0).barLow

        if array.size(sortedTpLevels) >= 1
            float tp1 = array.get(sortedTpLevels, 0)
            tp1Level := tp1 * 0.99 
            tp1Line = line.new(bar_index, tp1Level, bar_index + 75, tp1Level, color=color.purple, style=line.style_solid, width=2)
            array.push(tpSlLines, tp1Line)
            tp1Label = label.new(bar_index + 75, tp1Level, text='Liq TP (-%1)', color=color.new(color.purple,0), textcolor=color.white, style=label.style_label_left, size=size.small)
            array.push(tpSlLabels, tp1Label)
        else if not na(mainTPLevel)
            tp1Level := mainTPLevel
            mainLine = line.new(bar_index, tp1Level, bar_index + 75, tp1Level, color=color.purple, style=line.style_solid, width=2)
            array.push(tpSlLines, mainLine)
            mainLabel = label.new(bar_index + 75, tp1Level, text='OB TP', color=color.new(color.purple,0), textcolor=color.white, style=label.style_label_left, size=size.small)
            array.push(tpSlLabels, mainLabel)
        
        if not na(slLevel)
            slLine = line.new(bar_index, slLevel, bar_index + 75, slLevel, color=color.purple, style=line.style_solid, width=2)
            array.push(tpSlLines, slLine)
            slLabel = label.new(bar_index + 75, slLevel, text='SL', color=color.new(color.purple,0), textcolor=color.white, style=label.style_label_left, size=size.small)
            array.push(tpSlLabels, slLabel)
        [tpSlLines, tpSlLabels, tp1Level, slLevel]
    else
        float sl_SR = na
        nearestResForSL = getNearestNLevels(resistanceLevels_arr, entryPrice, 1, true)
        if array.size(nearestResForSL) > 0
            float resPivot = array.get(nearestResForSL, 0)
            [resU, resL] = getBandBounds(resPivot)
            sl_SR := resU
        float sl_ATR = entryPrice + (scaledAtr * atrSLMultiplier)
        if na(sl_SR)
            slLevel := sl_ATR
        else
            slLevel := math.min(sl_SR, sl_ATR)

        nearestSupportsForTP = getNearestNLevels(supportLevels_arr, entryPrice, 3, false)
        if array.size(nearestSupportsForTP) > 0
            for k = 0 to array.size(nearestSupportsForTP) - 1
                float supPivot = array.get(nearestSupportsForTP, k)
                [supU, supL] = getBandBounds(supPivot)
                array.push(sortedTpLevels, supU)
        
        float mainTPLevel = na
        if array.size(orderBlocks_arr) > 0
            mainTPLevel := array.get(orderBlocks_arr, 0).barHigh

        if array.size(sortedTpLevels) >= 1
            float tp1 = array.get(sortedTpLevels, 0)
            tp1Level := tp1 * 1.01
            tp1Line = line.new(bar_index, tp1Level, bar_index + 75, tp1Level, color=color.purple, style=line.style_solid, width=2)
            array.push(tpSlLines, tp1Line)
            tp1Label = label.new(bar_index + 75, tp1Level, text='Liq TP (+%1)', color=color.new(color.purple,0), textcolor=color.white, style=label.style_label_left, size=size.small)
            array.push(tpSlLabels, tp1Label)
        else if not na(mainTPLevel)
            tp1Level := mainTPLevel
            mainLine = line.new(bar_index, tp1Level, bar_index + 75, tp1Level, color=color.purple, style=line.style_solid, width=2)
            array.push(tpSlLines, mainLine)
            mainLabel = label.new(bar_index + 75, tp1Level, text='OB TP', color=color.new(color.purple,0), textcolor=color.white, style=label.style_label_left, size=size.small)
            array.push(tpSlLabels, mainLabel)
        
        if not na(slLevel)
            slLine = line.new(bar_index, slLevel, bar_index + 75, slLevel, color=color.purple, style=line.style_solid, width=2)
            array.push(tpSlLines, slLine)
            slLabel = label.new(bar_index + 75, slLevel, text='SL', color=color.new(color.purple,0), textcolor=color.white, style=label.style_label_left, size=size.small)
            array.push(tpSlLabels, slLabel)
        [tpSlLines, tpSlLabels, tp1Level, slLevel]

[buyScore, buyScoreDetails] = calculateScore(true)
[sellScore, sellScoreDetails] = calculateScore(false)

// --- SMART FILTERS (ALICE EDITION) ---
bool isIndex = syminfo.tickerid == "SP:SPX" or syminfo.tickerid == "NASDAQ:NDX" or syminfo.tickerid == "TVC:SPX" or syminfo.tickerid == "TVC:NDX"

bool filterIndex_Buy = false
bool filterIndex_Sell = false
bool filterStock_Buy = false
bool filterStock_Sell = false

if useSmartFilters and is_tf_supported
    if isIndex
        if d_isDXY_Bull and d_isYield_Bull
            filterIndex_Buy := true
        if not d_isDXY_Bull and not d_isYield_Bull
            filterIndex_Sell := true
    else 
        if trend_SPX_Price == -1
            filterStock_Buy := true

bool buySignalCondition = buyScore >= 100
bool sellSignalCondition = sellScore >= 100

float deviationThreshold = 5.0
float distFromZLT = math.abs(close - zltZlema) / zltZlema * 100
bool isDeviationSafe = distFromZLT < deviationThreshold

// --- ZLT TREND FILTER (STRICT) ---
bool zltConditionBuy = useZltTrendFilter ? (zltTrend == 1) : true
bool zltConditionSell = useZltTrendFilter ? (zltTrend == -1) : true

bool validBuySignal = showBuySignals and buySignalCondition and not filterIndex_Buy and not filterStock_Buy and isDeviationSafe and zltConditionBuy
bool validSellSignal = showSellSignals and sellSignalCondition and not filterIndex_Sell and not filterStock_Sell and isDeviationSafe and zltConditionSell

rsiValue = ta.rsi(close, 14)
var bool hasHitTP = false 

if monitoringTrend and not monitoringTrend[1]
    hasHitTP := false

// ==========================================
// EXIT MANTIGI (HYBRID: PUAN + TRAILING STOP)
// ==========================================
// Bu bayrak, ters sinyal durumunda bir sonraki blogun girisi zorlamasi icin
bool wasReversalExit = false 

if monitoringTrend and barstate.isconfirmed and is_tf_supported
    bool forceExit = false
    float exitPnl = 0.0
    float currentPrice = close
    float exitScore = 0.0
    float qqeHistVal = qqeRsiLine - 50 
    string exitDetails = "" 

    // --- 0. TRAILING STOP HESABI (YENI) ---
    float currentTrailLevel = na
    bool isTrailBroken = false
    
    if useTrailingPoints
        float atrVal = ta.atr(14) * atrTrailMult
        if monitoringIsBuy
            highestHighSinceEntry := math.max(nz(highestHighSinceEntry, close), high)
            currentTrailLevel := highestHighSinceEntry - atrVal
            if close < currentTrailLevel
                isTrailBroken := true
        else
            lowestLowSinceEntry := math.min(nz(lowestLowSinceEntry, close), low)
            currentTrailLevel := lowestLowSinceEntry + atrVal
            if close > currentTrailLevel
                isTrailBroken := true
        
        // Görsellik: Trailing Stop Degeri (Plot icin)
        trailLevelForPlot := currentTrailLevel

    // --- 1. TERS SINYAL KONTROLU (R:R FILTRELI) ---
    // Ters sinyal geldi ama girmeye deger mi? Degmezse EXIT YAPMA.
    
    // A) LONG ISE VE SHORT GELDI ISE
    if monitoringIsBuy and validSellSignal
        // Sanal bir Short TP/SL hesabi yap
        [t_lines, t_labels, t_tp, t_sl] = drawTPAndSLAndReturnLines(false, close, supportLevels, resistanceLevels, internalOrderBlocks)
        float t_rr = 0.0
        if not na(t_tp) and not na(t_sl)
            float t_risk = math.abs(t_sl - close)
            float t_reward = math.abs(close - t_tp)
            if t_risk > 0
                t_rr := t_reward / t_risk
        
        // Temizlik (Cizgileri hemen sil)
        deleteSpecificLines(t_lines, t_labels)

        // KARAR: Eger R:R guzel ise veya minRR 0 ise CIK
        if t_rr >= minRR
            forceExit := true
            wasReversalExit := true 
            exitPnl := (currentPrice - monitoringEntryPrice) / monitoringEntryPrice * 100
            exitDetails := "Ters Sinyal (Short Geldi)"
    
    // B) SHORT ISE VE LONG GELDI ISE
    if not monitoringIsBuy and validBuySignal
        // Sanal bir Long TP/SL hesabi yap
        [t_lines, t_labels, t_tp, t_sl] = drawTPAndSLAndReturnLines(true, close, supportLevels, resistanceLevels, internalOrderBlocks)
        float t_rr = 0.0
        if not na(t_tp) and not na(t_sl)
            float t_risk = math.abs(close - t_sl)
            float t_reward = math.abs(t_tp - close)
            if t_risk > 0
                t_rr := t_reward / t_risk
        
        deleteSpecificLines(t_lines, t_labels)

        if t_rr >= minRR
            forceExit := true
            wasReversalExit := true 
            exitPnl := (monitoringEntryPrice - currentPrice) / monitoringEntryPrice * 100
            exitDetails := "Ters Sinyal (Long Geldi)"

    // 2. ANA EXIT MANTIGI (STANDART PUANLAMA + TRAILING)
    if not forceExit
        float vol_atr_current = ta.atr(14)
        bool isOppositeCandle = monitoringIsBuy ? close < open : close > open

        float dist_zlt_raw = 0.0
        if monitoringIsBuy
            dist_zlt_raw := (high - zltZlema) / zltZlema * 100
        else
            dist_zlt_raw := (zltZlema - low) / zltZlema * 100
        
        float dist_zlt_percent = math.max(0.0, dist_zlt_raw)

        // === TRAILING STOP PUANI EKLEME ===
        if isTrailBroken
            exitScore += 30
            exitDetails += "Trailing Stop Kirildi (+20)\n"

        // === LONG EXIT PUANLAMASI ===
        if monitoringIsBuy 
            if rsiValue > 70
                exitScore += 10
                exitDetails += "RSI > 70 (+10)\n"

            if hasHitTP or (not na(lastTPPrice) and high >= lastTPPrice)
                hasHitTP := true
                exitScore += 10
                exitDetails += "TP Hit (+10)\n"

            if qqeHistVal < qqeHistVal[1]
                exitScore += 5
            if isStochSellCross
                exitScore += 10
                exitDetails += "Stoch Sat (+10)\n"
            if isZltBearishTrendChange
                exitScore += 20
                exitDetails += "ZLT Trend Donusu (+20)\n"

            if isOppositeCandle and high > zltZlema
                if dist_zlt_percent >= 10.0
                    exitScore += 50
                    exitDetails += "Mesafe > %10 (+50)\n"
                else if dist_zlt_percent >= 8.0
                    exitScore += 40
                    exitDetails += "Mesafe > %8 (+40)\n"
                else if dist_zlt_percent >= 6.0
                    exitScore += 30
                    exitDetails += "Mesafe > %6 (+30)\n"
                else if dist_zlt_percent >= 4.0
                    exitScore += 20
                    exitDetails += "Mesafe > %4 (+20)\n"
                else if dist_zlt_percent >= 2.0
                    exitScore += 10
                    exitDetails += "Mesafe > %2 (+10)\n"

        // === SHORT EXIT PUANLAMASI ===
        else 
            if rsiValue < 30
                exitScore += 10
                exitDetails += "RSI < 30 (+10)\n"

            if hasHitTP or (not na(lastTPPrice) and low <= lastTPPrice)
                hasHitTP := true
                exitScore += 10
                exitDetails += "TP Hit (+10)\n"

            if qqeHistVal > qqeHistVal[1]
                exitScore += 5
            if isStochBuyCross
                exitScore += 10
                exitDetails += "Stoch Al (+10)\n"
            if isZltBullishTrendChange
                exitScore += 20
                exitDetails += "ZLT Trend Donusu (+20)\n"
            
            if isOppositeCandle and low < zltZlema
                if dist_zlt_percent >= 10.0
                    exitScore += 50
                    exitDetails += "Mesafe > %10 (+50)\n"
                else if dist_zlt_percent >= 8.0
                    exitScore += 40
                    exitDetails += "Mesafe > %8 (+40)\n"
                else if dist_zlt_percent >= 6.0
                    exitScore += 30
                    exitDetails += "Mesafe > %6 (+30)\n"
                else if dist_zlt_percent >= 4.0
                    exitScore += 20
                    exitDetails += "Mesafe > %4 (+20)\n"
                else if dist_zlt_percent >= 2.0
                    exitScore += 10
                    exitDetails += "Mesafe > %2 (+10)\n"

        if exitScore >= 50
            forceExit := true
            if monitoringIsBuy
                exitPnl := (currentPrice - monitoringEntryPrice) / monitoringEntryPrice * 100
            else
                exitPnl := (monitoringEntryPrice - currentPrice) / monitoringEntryPrice * 100
    
    // EXIT ISLEMI VE TABLO GUNCELLEME
    if forceExit
        monitoringTrend := false 
        totalExitSignals += 1
        totalProfitPercent += exitPnl

        if exitPnl > 0
            correctExitSignals += 1
            
        color exitColor = exitPnl > 0 ? color.purple : color.new(color.gray, 20)
        
        label.new(x = bar_index, y = high, text = "EXIT\n%" + str.tostring(exitPnl, "#.##") + "\nPuan: " + str.tostring(exitScore), tooltip = exitDetails, xloc = xloc.bar_index, yloc = monitoringIsBuy ? yloc.abovebar : yloc.belowbar, style = monitoringIsBuy ? label.style_label_down : label.style_label_up, color = exitColor, textcolor = color.white, size = size.small)
        alert("Jarvis Trend Exit Sinyali: " + syminfo.tickerid + " Kar: %" + str.tostring(exitPnl, "#.##"), alert.freq_once_per_bar_close)
        
        // Temizlik
        highestHighSinceEntry := na
        lowestLowSinceEntry := na
        trailLevelForPlot := na

// --- TP/SL KONTROLU ---
if isSignalActive and barstate.isconfirmed
    slHit = false
    tpHit = false
    if isLastSignalBuy
        if not na(lastSLPrice) and low <= lastSLPrice
            slHit := true
        else if not na(lastTPPrice) and high >= lastTPPrice
            tpHit := true
    else
        if not na(lastSLPrice) and high >= lastSLPrice
            slHit := true
        else if not na(lastTPPrice) and low <= lastTPPrice
            tpHit := true

    if slHit or tpHit
        if slHit
            totalSignals += 1
        else if tpHit
            correctSignals += 1
            totalSignals += 1
        isSignalActive := false 
        clearOldLines()
        highestHighSinceEntry := na
        lowestLowSinceEntry := na
        trailLevelForPlot := na

// --- SINYAL GIRISLERI ---
if bar_index >= (last_bar_index - 500) and is_tf_supported
    // AL SINYALI
    if validBuySignal and not monitoringTrend and lastTradeDirection != 1
        clearOldLines()
        [linesArr, labelsArr, tpPrice, slPrice] = drawTPAndSLAndReturnLines(true, close, supportLevels, resistanceLevels, internalOrderBlocks)
        bool isValidTrade = false
        float rrOrani = 0.0
        if not na(tpPrice) and not na(slPrice)
            bool tpHitOnEntry = high >= tpPrice
            float risk = math.abs(close - slPrice)
            float getiri = math.abs(tpPrice - close)
            if risk > 0
                rrOrani := getiri / risk
                // REVERSAL ISE R:R KONTROLU YAPMA, ZATEN YUKARIDA YAPTIK
                if rrOrani >= minRR or wasReversalExit
                    isValidTrade := true
        
        if not isValidTrade
            deleteSpecificLines(linesArr, labelsArr) 
        else
            isSignalActive := true
            isLastSignalBuy := true
            lastBuySignalBar := bar_index
            lastBuySignalPrice := close
            lastTPPrice := tpPrice
            lastSLPrice := slPrice
            currentLines := linesArr
            currentLabels := labelsArr
            
            monitoringTrend := true
            monitoringIsBuy := true
            monitoringEntryPrice := close
            
            // TRAILING STOP BASLANGIC
            highestHighSinceEntry := high
            lowestLowSinceEntry := low // Short icin
            trailLevelForPlot := na // Ilk barda cizme
            
            lastTradeDirection := 1 
            wasReversalExit := false 

            zltBullCredit := false
            vidyaBullCredit := false

            lblText = str.tostring(buyScore, "#") + " | R:R: " + str.tostring(rrOrani, "#.#")
            label.new(x = bar_index, y = low - scaledAtr, text = lblText, tooltip = buyScoreDetails, xloc = xloc.bar_index, style = label.style_label_up, color = color.new(color.green, 0), textcolor = color.white, size = size.small)
            alert("Jarvis Al Sinyali: " + syminfo.tickerid + " Puan: " + str.tostring(buyScore) + " R:R: " + str.tostring(rrOrani, "#.#") + "\nDetaylar:\n" + buyScoreDetails, alert.freq_once_per_bar_close)
    
    // SAT SINYALI
    if validSellSignal and not monitoringTrend and lastTradeDirection != -1
        clearOldLines()
        [linesArr, labelsArr, tpPrice, slPrice] = drawTPAndSLAndReturnLines(false, close, supportLevels, resistanceLevels, internalOrderBlocks)
        bool isValidTrade = false
        float rrOrani = 0.0
        if not na(tpPrice) and not na(slPrice)
            bool tpHitOnEntry = low <= tpPrice
            float risk = math.abs(slPrice - close)
            float getiri = math.abs(close - tpPrice)
            if risk > 0
                rrOrani := getiri / risk
                // REVERSAL ISE R:R KONTROLU YAPMA
                if rrOrani >= minRR or wasReversalExit
                    isValidTrade := true
        
        if not isValidTrade
            deleteSpecificLines(linesArr, labelsArr)
        else
            isSignalActive := true
            isLastSignalBuy := false
            lastSellSignalBar := bar_index
            lastSellSignalPrice := close
            lastTPPrice := tpPrice
            lastSLPrice := slPrice
            currentLines := linesArr
            currentLabels := labelsArr

            monitoringTrend := true
            monitoringIsBuy := false
            monitoringEntryPrice := close

            // TRAILING STOP BASLANGIC
            highestHighSinceEntry := high
            lowestLowSinceEntry := low
            trailLevelForPlot := na

            lastTradeDirection := -1 
            wasReversalExit := false

            zltBearCredit := false
            vidyaBearCredit := false

            lblText = str.tostring(sellScore, "#") + " | R:R: " + str.tostring(rrOrani, "#.#")
            label.new(x = bar_index, y = high + scaledAtr, text = lblText, tooltip = sellScoreDetails, xloc = xloc.bar_index, style = label.style_label_down, color = color.new(color.red, 0), textcolor = color.white, size = size.small)
            alert("Jarvis Sat Sinyali: " + syminfo.tickerid + " Puan: " + str.tostring(sellScore) + " R:R: " + str.tostring(rrOrani, "#.#") + "\nDetaylar:\n" + sellScoreDetails, alert.freq_once_per_bar_close)

// ==========================================
// 8. VISUALS & PLOTS
// ==========================================
plot(is_tf_supported and showEMA ? nz(ema8, na) : na, color = color.new(color.white, 0), title = "8 Gunluk EMA", linewidth = 2)
plot(is_tf_supported and showEMA ? nz(ema200, na) : na, color = color.new(color.orange, 0), title = "200 Gunluk EMA", linewidth = 2)

p_upper = plot(is_tf_supported and showBollinger ? upper : na, color = color.new(color.blue, 0), title = "Bollinger Upper", linewidth = 1)
p_basis = plot(is_tf_supported and showBollinger ? basis : na, color = color.new(color.gray, 50), title = "Bollinger Basis", linewidth = 1)
p_lower = plot(is_tf_supported and showBollinger ? lower : na, color = color.new(color.purple, 0), title = "Bollinger Lower", linewidth = 1)
fill(p_upper, p_basis, color.new(color.blue, 95)) 
fill(p_lower, p_basis, color.new(color.purple, 95))

qqeColor = qqeRsiLine - 50 > 0 ? #00c3ff : #ff0062
plot(is_tf_supported and showQQE ? qqeRsiLine - 50 : na, title = "QQE RSI Line", color = color.new(qqeColor, 0), linewidth = 2)
plot(is_tf_supported and showQQE ? qqeRsiLine - 50 : na, title = "QQE Histogram", color = color.new(qqeColor, 0), style = plot.style_columns)

zltColor = zltTrend == 1 ? color.new(#00ffbb, 70) : color.new(#ff1100, 70)
zltPlot = plot(is_tf_supported and showZLT ? zltZlema : na, title = "Zero Lag Basis", linewidth = 2, color = zltColor)
zltUpperPlot = plot(is_tf_supported and showZLT and zltTrend == -1 ? zltZlema + zltVolatility : na, style = plot.style_linebr, color = color.new(#ff1100, 90), title = "ZLT Upper Band")
zltLowerPlot = plot(is_tf_supported and showZLT and zltTrend == 1 ? zltZlema - zltVolatility : na, style = plot.style_linebr, color = color.new(#00ffbb, 90), title = "ZLT Lower Band")
fill(zltPlot, zltUpperPlot, color.new(#ff1100, 90))
fill(zltPlot, zltLowerPlot, color.new(#00ffbb, 90))

var float vidya_smoothed_value = na
if is_vidya_trend_up
    vidya_smoothed_value := vidya_lower_band
else
    vidya_smoothed_value := vidya_upper_band
vidya_trend_color = is_vidya_trend_up ? vidya_up_trend_color : vidya_down_trend_color
p1_vidya = plot(is_tf_supported and showVolumaticVidya ? vidya_smoothed_value : na, title = "VIDYA Trend", linewidth = 2)
p2_vidya = plot(is_tf_supported and showVolumaticVidya ? hl2 : na, display = display.none)
fill(p1_vidya, p2_vidya, color.new(vidya_trend_color, 80))

// Trailing Plot
plot(trailLevelForPlot, title="Trailing Stop History", color=color.yellow, style=plot.style_linebr, linewidth=2)

// ==========================================
// 9. DUAL DASHBOARD SYSTEM
// ==========================================
var table jarvisStatsTbl = table.new(position.bottom_right, 2, 8, border_width = 1)
var table jarvisMarketTbl = table.new(position.bottom_left, 2, 7, border_width = 1)

var table errorTbl = table.new(position.middle_center, 1, 1)
if not is_tf_supported and barstate.islast
    table.cell(errorTbl, 0, 0, "BU ZAMAN DILIMI DESTEKLENMIYOR\nLutfen 1S, 2S, 3S, 4S, Gunluk veya Haftalik kullanin.", bgcolor=color.red, text_color=color.white, text_size=size.large)
else
    table.clear(errorTbl, 0, 0)

tableBgColor = showDashboard ? color.new(#1e222d, 20) : color.new(#1e222d, 100)
tableBorderColor = showDashboard ? color.new(#ffffff, 50) : color.new(#ffffff, 100)
tableTextColor = showDashboard ? color.white : color.new(color.white, 100)

table.set_bgcolor(jarvisStatsTbl, tableBgColor)
table.set_border_color(jarvisStatsTbl, tableBorderColor)
table.set_bgcolor(jarvisMarketTbl, tableBgColor)
table.set_border_color(jarvisMarketTbl, tableBorderColor)

tradeWR = totalSignals > 0 ? (correctSignals / totalSignals) * 100 : 0
tradeWRText = str.tostring(tradeWR, "#.##") + "% (" + str.tostring(correctSignals, "#") + "/" + str.tostring(totalSignals, "#") + ")"

exitWR = totalExitSignals > 0 ? (correctExitSignals / totalExitSignals) * 100 : 0
exitWRText = str.tostring(exitWR, "#.##") + "% (" + str.tostring(correctExitSignals, "#") + "/" + str.tostring(totalExitSignals, "#") + ")"

var string seasonText = "YONSUZ"
var color seasonColor = color.new(color.gray, 70)

if d_isSPX_Bull
    if d_isTech_Bull
        seasonText := "RALLY (Risk-On)"
        seasonColor := color.new(color.green, 70)
    else
        seasonText := "GENEL POZITIF"
        seasonColor := color.new(color.orange, 70)
else
    if d_isDXY_Bull and d_isYield_Bull
        seasonText := "BASKI (Risk-Off)"
        seasonColor := color.new(color.red, 70)
    else
        seasonText := "DUSUS / YONSUZ"
        seasonColor := color.new(color.gray, 70)

us10yColor = d_isYield_Bull ? color.red : color.green 
dxyColor = d_isDXY_Bull ? color.red : color.green
vixColor = d_isVIX_Bull ? color.red : color.green
spxColor = d_isSPX_Bull ? color.green : color.red
techColor = d_isTech_Bull ? color.green : color.red

string htf_display_text = tf_htf == "240" ? "4H" : (tf_htf == "D" ? "Daily" : (tf_htf == "W" ? "Weekly" : (tf_htf == "M" ? "Monthly" : tf_htf)))
string ltf_display_text = tf_ltf + "m"
string filter_display_text = tf_filter == "60" ? "1H" : (tf_filter == "240" ? "4H" : (tf_filter == "D" ? "Daily" : tf_filter))

if showDashboard and is_tf_supported
    table.cell(jarvisStatsTbl, 0, 0, "ALICE STRATEJI", text_color = tableTextColor, bgcolor=color.new(color.gray, 60))
    table.cell(jarvisStatsTbl, 1, 0, "DURUM", text_color = tableTextColor, bgcolor=color.new(color.gray, 60))
    
    table.cell(jarvisStatsTbl, 0, 1, "LTF (MOM)", text_color = tableTextColor, text_halign=text.align_left)
    table.cell(jarvisStatsTbl, 1, 1, ltf_display_text, text_color = color.white, bgcolor = isBull1H ? color.green : color.red)
    
    table.cell(jarvisStatsTbl, 0, 2, "HTF (TREND)", text_color = tableTextColor, text_halign=text.align_left)
    table.cell(jarvisStatsTbl, 1, 2, htf_display_text, text_color = color.white, bgcolor = isDailyBull_raw ? color.green : color.red)

    table.cell(jarvisStatsTbl, 0, 3, "FILTER TF", text_color = tableTextColor, text_halign=text.align_left)
    table.cell(jarvisStatsTbl, 1, 3, filter_display_text, text_color = color.white, bgcolor = color.blue)

    table.cell(jarvisStatsTbl, 0, 4, "TP/SL WR", text_color = tableTextColor, text_halign=text.align_left)
    table.cell(jarvisStatsTbl, 1, 4, tradeWRText, text_color = tableTextColor)

    table.cell(jarvisStatsTbl, 0, 5, "EXIT WR", text_color = tableTextColor, text_halign=text.align_left)
    table.cell(jarvisStatsTbl, 1, 5, exitWRText, text_color = tableTextColor)

    // Volatilite Skoru (Mesafe Bazli)
    float dist_zlt_raw = (math.abs(close - zltZlema) / zltZlema) * 100
    float vol_score_unit = math.max(0.0, dist_zlt_raw)
    
    color volScoreColor = vol_score_unit > 4.0 ? color.orange : (vol_score_unit > 2.0 ? color.green : color.gray)
    table.cell(jarvisStatsTbl, 0, 6, "ZLT DISTANCE", text_color = tableTextColor, text_halign=text.align_left)
    table.cell(jarvisStatsTbl, 1, 6, "%" + str.tostring(vol_score_unit, "#.##"), text_color = color.white, bgcolor = volScoreColor)

    color pnlColor = totalProfitPercent >= 0 ? color.green : color.red
    table.cell(jarvisStatsTbl, 0, 7, "TOTAL PNL", text_color = tableTextColor, text_halign=text.align_left)
    table.cell(jarvisStatsTbl, 1, 7, str.tostring(totalProfitPercent, "#.##") + "%", text_color = color.white, bgcolor = pnlColor)

    // --- TABLO 2: WALL STREET VERISI ---
    table.cell(jarvisMarketTbl, 0, 0, "WALL ST. DATA", text_color = tableTextColor, bgcolor=color.new(color.gray, 60))
    table.cell(jarvisMarketTbl, 1, 0, "YON", text_color = tableTextColor, bgcolor=color.new(color.gray, 60))

    table.cell(jarvisMarketTbl, 0, 1, "SEZON", text_color = tableTextColor, text_halign=text.align_left)
    table.cell(jarvisMarketTbl, 1, 1, seasonText, text_color = color.white, bgcolor = seasonColor)

    table.cell(jarvisMarketTbl, 0, 2, "US10Y", text_color = tableTextColor, text_halign=text.align_left)
    table.cell(jarvisMarketTbl, 1, 2, d_isYield_Bull ? "UP" : "DN", text_color = color.white, bgcolor = us10yColor)

    table.cell(jarvisMarketTbl, 0, 3, "DXY", text_color = tableTextColor, text_halign=text.align_left)
    table.cell(jarvisMarketTbl, 1, 3, d_isDXY_Bull ? "UP" : "DN", text_color = color.white, bgcolor = dxyColor)

    table.cell(jarvisMarketTbl, 0, 4, "VIX", text_color = tableTextColor, text_halign=text.align_left)
    table.cell(jarvisMarketTbl, 1, 4, d_isVIX_Bull ? "UP" : "DN", text_color = color.white, bgcolor = vixColor)

    table.cell(jarvisMarketTbl, 0, 5, "SPX", text_color = tableTextColor, text_halign=text.align_left)
    table.cell(jarvisMarketTbl, 1, 5, d_isSPX_Bull ? "UP" : "DN", text_color = color.white, bgcolor = spxColor)

    table.cell(jarvisMarketTbl, 0, 6, "TECH (XLK)", text_color = tableTextColor, text_halign=text.align_left)
    table.cell(jarvisMarketTbl, 1, 6, d_isTech_Bull ? "UP" : "DN", text_color = color.white, bgcolor = techColor)

// ALARMS
alertcondition(currentAlerts.swingBullishBOS, 'Swing Bullish BOS', 'Swing Bullish BOS olustu')
alertcondition(currentAlerts.swingBullishCHoCH, 'Swing Bullish CHoCH', 'Swing Bullish CHoCH olustu')
alertcondition(currentAlerts.swingBearishBOS, 'Swing Bearish BOS', 'Swing Bearish BOS olustu')
alertcondition(currentAlerts.swingBearishCHoCH, 'Swing Bearish CHoCH', 'Swing Bearish CHoCH olustu')
alertcondition(currentAlerts.bullishFairValueGap, 'Bullish FVG', 'Bullish FVG olustu')
alertcondition(currentAlerts.bearishFairValueGap, 'Bearish FVG', 'Bearish FVG olustu')
alertcondition(currentAlerts.equalHighs, 'Equal Highs', 'Equal Highs tespit edildi')
alertcondition(currentAlerts.equalLows, 'Equal Lows', 'Equal Lows tespit edildi')